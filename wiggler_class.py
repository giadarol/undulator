# Compact, refactored Wiggler
# - Less duplication via helpers and component loops
# - Clear ensure() dependency gates
# - Generic sine-fitting used for fields and curvature
# - Small quality-of-life utilities (mid masks, magnitude, plotting core)
#
# Public API preserved (same method names), plus docstrings tightened.

from __future__ import annotations

import numpy as np
import pandas as pd
import scipy as sc
import sympy as sp
from bpmeth import poly_fit
from scipy.signal import find_peaks
from scipy.optimize import curve_fit
from numpy.polynomial import Polynomial
import matplotlib.pyplot as plt


# ================================ Main class ================================

class Wiggler:

    def __init__(
        self,
        file_path,
        xy_point=(0, 0),
        dx=0.001,
        dy=0.001,
        ds=0.001,
        peak_window=(100, 2100),
        n_modes=[3, 3, 3],
        poly_deg = [[15, 15], [15, 15], [15, 15]],
        poly_pieces=[[3, 3], [3, 3], [3, 3]],
        der=False,
        filter_params=None,
    ):

        self.file_path = file_path
        self.xy_point = xy_point
        self.dx, self.dy, self.ds = dx, dy, ds
        self.peak_window = peak_window

        # NOTE: Filter noise is now only used for the right tails, because those are noisy.
        # We can add a more general functionality later.
        self.filter_params = filter_params

        self.shapes = {
            "Bx": {"n_modes": n_modes[0], "poly_deg_L": poly_deg[0][0], "poly_deg_R": poly_deg[0][1],
                   "n_pieces_L": poly_pieces[0][0], "n_pieces_R": poly_pieces[0][1]},
            "By": {"n_modes": n_modes[1], "poly_deg_L": poly_deg[1][0], "poly_deg_R": poly_deg[1][1],
                   "n_pieces_L": poly_pieces[1][0], "n_pieces_R": poly_pieces[1][1]},
            "Bs": {"n_modes": n_modes[2], "poly_deg_L": poly_deg[2][0], "poly_deg_R": poly_deg[2][1],
                   "n_pieces_L": poly_pieces[2][0], "n_pieces_R": poly_pieces[2][1]},
        }

        self.df = None
        self.s_full = None
        self.der = der

        # Dictionary that holds a list of borders for each field
        self.borders_idx  = {"Bx": None, "By": None, "Bs": None}
        self.poly_borders = {"Bx": [], "By": [], "Bs": []}

        # Data dictionaries
        # raw_data holds the data from the file
        # fit_data holds the data generated by fitting
        self.raw_data   = {"Bx": None, "By": None, "Bs": None}
        self.fit_data   = {"Bx": None, "By": None, "Bs": None}

        # Dictionary to hold lists of fitted parameters for each field component
        self.fit_pars = {"Bx" : {}, "By" : {}, "Bs" : {}}


    # PUBLIC
    # Setter method that calls all the other methods to arrive at a fit.
    def set(self):
        self._parse_to_dataframe()
        self.select_xy()
        if self.filter_params != None:
            self._filter_noise()
        self._find_regions()
        self._fit_sinusoids()
        self._fit_edges()



    ####################################################################################################################
    # EVALUATION FUNCTIONS
    ####################################################################################################################

    # PRIVATE
    # This function evaluates a sum of (co)sines at the given x values.
    # The parameters are given as a flat list, where each mode has three parameters:
    #  - Amplitude of the cosine term
    #  - Amplitude of the sine term
    #  - Wave number
    # Thus, for n modes, the parameter list has length 3*n.
    @staticmethod
    def _sinusoid(x, *params):
        # Define the output array
        y = np.zeros_like(x, dtype=np.float64)

        # The range depends on the number of sinusoids there are present in the function.
        # B_x is best approximated with two, whereas B_y only needs one.
        # Note the integer division by 3, because each mode has three parameters.
        for A1, A2, k in zip(params[::3], params[1::3], params[2::3]):
            # General sinusoidal part is a linear combination of cosine and sine.
            # This is equivalent to a single function with a phase-offset, but more numerically stable.
            y += A1 * np.cos(k * x) + A2 * np.sin(k * x)

        if (len(params) % 3) == 1:
            y += params[-1]

        return y



    ####################################################################################################################
    # IDENTIFYING REGIONS AND SETTING BORDERS IN DATA CLASSES
    ####################################################################################################################

    # PRIVATE
    # This method reads the data from the file and stores it in a pandas DataFrame.
    def _parse_to_dataframe(self) -> None:
        df = pd.read_csv(
            self.file_path, sep=r"\s+", header=None, names=["X", "Y", "Z", "Bx", "By", "Bs"]
        )
        df.set_index(["X", "Y", "Z"], inplace=True)
        self.df = df

    # PUBLIC
    # This method selects the data at the specified (x,y) point and stores it in the fields dictionary.
    # It is made public so that the user can change the (x,y) point and re-select the data without re-parsing the file.
    def select_xy(self):
        subset = self.df.xs(self.xy_point, level=["X", "Y"]).sort_index()

        self.s_full = subset.index.to_numpy() * self.ds

        # Store the raw data for each field.

        for field in ["Bx", "By", "Bs"]:
            if self.der == False:
                self.raw_data[field] = subset[field].to_numpy()

            else:
                self._fit_transverse_parabolas()

            self.fit_data[field] = np.zeros_like(self.raw_data[field])

    @staticmethod
    def find_sign_change_indices(y, eps=0.0):
        """
        Indices i where y[i] and y[i+1] have opposite signs.
        Exact zeros are not counted as crossings.

        eps > 0 treats |y| <= eps as 0 to add a small hysteresis.
        """
        y = np.asarray(y, float)
        if eps > 0:
            y = np.where(np.abs(y) <= eps, 0.0, y)

        y0 = y[:-1]
        y1 = y[1:]

        valid = ~np.isnan(y0) & ~np.isnan(y1)
        crossings = valid & (y0 * y1 < 0)  # strict sign change
        return np.flatnonzero(crossings)

    # PRIVATE
    # This method first finds the peaks and valleys in the data for Bx and By
    # Then, it combines them into one array for the extrema of Bx and By
    # Finally, it sets the borders_idx attribute of the FieldChannel objects for Bx and By
    def _find_regions(self):
        w_left = self.peak_window[0]
        w_right = self.peak_window[1]

        for field in ["Bx", "By", "Bs"]:
            field_peaks = find_peaks(self.raw_data[field])[0]
            field_valleys = find_peaks(-self.raw_data[field])[0]
            field_peaks = field_peaks[np.logical_and(field_peaks > w_left, field_peaks < w_right)]
            field_valleys = field_valleys[np.logical_and(field_valleys > w_left, field_valleys < w_right)]
            field_extrema = np.sort(np.concatenate((field_peaks, field_valleys)))
            if not self.der:
                self.borders_idx[field] = [field_extrema[4], field_extrema[-4]]
            else:
                self.borders_idx[field] = [field_extrema[4], field_extrema[-4]]


    # PRIVATE
    # This is an impromptu noise-filter.
    # Will probably need to be improved later.
    # For now, it only filters noise from the right tail of the data, because that's where the noise is present.
    def _filter_noise(self):
        from scipy.signal import savgol_filter
        from scipy.signal import medfilt

        left_idx = self.filter_params[0]
        right_idx = self.filter_params[1]
        kernel_size = self.filter_params[2]
        window_length = self.filter_params[3]
        polyorder = self.filter_params[4]

        for field in ["Bx", "By", "Bs"]:

            # Because Bs is very noisy, we also filter the left tail.
            # This is not necessary for Bx and By, because their left tails are not noisy.
            if field == "Bs":
                tail = slice(None, left_idx)
                m = medfilt(self.raw_data[field][tail].copy(), kernel_size=kernel_size)
                y_sm = savgol_filter(m, window_length=window_length, polyorder=polyorder)
                self.raw_data[field][tail] = y_sm

                tail = slice(right_idx, None)
                m = medfilt(self.raw_data[field][tail].copy(), kernel_size=kernel_size)  # kernel_size must be odd
                y_sm = savgol_filter(m, window_length=window_length, polyorder=polyorder)
                self.raw_data[field][tail] = y_sm

            tail = slice(right_idx, None)
            m = medfilt(self.raw_data[field][tail].copy(), kernel_size=kernel_size)  # kernel_size must be odd
            y_sm = savgol_filter(m, window_length=window_length, polyorder=polyorder)
            self.raw_data[field][tail] = y_sm



    ####################################################################################################################
    # SINUSOID FITTING
    ####################################################################################################################

    # PRIVATE
    # This function finds the amplitudes and frequencies of the (co)sines present in the data.
    @staticmethod
    def _find_modes(x, y, dx, n_modes):
        # Fourier Transform and frequencies
        fft = sc.fft.fft(y)
        fftfreq = sc.fft.fftfreq(len(x), dx)

        # Only keep positive frequencies
        fft = fft[fftfreq > 0]
        fftfreq = fftfreq[fftfreq > 0]

        # Find peaks in the magnitude spectrum
        peaks = find_peaks(np.abs(fft))[0]

        # Order peaks by magnitude, descending
        order = np.argsort(np.abs(fft[peaks]))[::-1]
        peaks = peaks[order][:n_modes]

        # Extract amplitudes and frequencies in the same order
        amplitudes = fft[peaks]
        cos_amps = 2 * dx * amplitudes.real
        sin_amps = -2 * dx * amplitudes.imag
        k_values = 2 * np.pi * fftfreq[peaks]

        return cos_amps, sin_amps, k_values

    # PRIVATE
    # This method fits sinusoids to the data in the regions defined by borders_idx.
    # The fitted parameters are stored in the fit_pars attribute.
    # The fitted data is stored in the fit_data attribute.
    # It uses the _find_modes function to get initial guesses for the parameters.
    def _fit_sinusoids(self, fun=True):
        for field in ["Bx", "By", "Bs"]:
            sin_slice = slice(self.borders_idx[field][0], self.borders_idx[field][1])
            s_reg = self.s_full[sin_slice]

            if fun:
                field_reg = self.raw_data[field][sin_slice]
            else:
                field_reg = self.trans_der2[field][sin_slice]

            n_modes = self.shapes[field]["n_modes"]

            cos_amps, sin_amps, k_modes = self._find_modes(s_reg, field_reg, self.ds, n_modes)

            # after:
            p0 = np.zeros(n_modes * 3 + 1)
            p0[-1] = float(np.mean(field_reg))  # DC guess

            for ii in range(n_modes):
                p0[3 * ii + 0] = cos_amps[ii]
                p0[3 * ii + 1] = sin_amps[ii]
                p0[3 * ii + 2] = k_modes[ii]

            popt, pcov = curve_fit(self._sinusoid, s_reg, field_reg, p0=p0)

            if fun:
                self.fit_pars[field]["sines"] = popt
                self.fit_data[field][sin_slice] = self._sinusoid(s_reg, *popt)
            else:
                self.der2_fit_pars[field]["sines"] = popt
                self.fit_der2[field][sin_slice] = self._sinusoid(s_reg, *popt)

    ####################################################################################################################
    # PIECEWISE POLYNOMIAL FITTING
    ####################################################################################################################

    # PRIVATE
    # Takes the fit parameters from the sinusoidal fit
    # and computes the boundary conditions for the polynomial fits
    # fL, fR are the function values at the left and right boundaries
    # dL, dR are the first derivatives at the left and right boundaries
    # ddL, ddR are the second derivatives at the left and right boundaries
    def _boundary_from_sine(self, field, s_mid):
        xL, xR = s_mid[0] - self.ds, s_mid[-1] + self.ds
        fL = fR = dL = dR = ddL = ddR = 0.0
        params = self.fit_pars[field]["sines"]  # however you access the fitted vector for the current field
        for Ac, As, k in zip(params[::3], params[1::3], params[2::3]):
            fL += Ac * np.cos(k * xL) + As * np.sin(k * xL)
            fR += Ac * np.cos(k * xR) + As * np.sin(k * xR)
            dL += k * (As * np.cos(k * xL) - Ac * np.sin(k * xL))
            dR += k * (As * np.cos(k * xR) - Ac * np.sin(k * xR))
            ddL += -(k * k) * (Ac * np.cos(k * xL) + As * np.sin(k * xL))
            ddR += -(k * k) * (Ac * np.cos(k * xR) + As * np.sin(k * xR))
        # DC only shifts values:
        if (len(params) % 3) == 1:
            c0 = params[-1]
            fL += c0;
            fR += c0
        return np.array([fL, fR, dL, dR, ddL, ddR], dtype=float)

    # PRIVATE
    # This method computes the boundary conditions from a previously fitted polynomial.
    # xL, xR are the left and right boundaries of the new region.
    # dp and ddp are the first and second derivatives of the polynomial.
    def _boundary_from_poly(self, s_prev, poly):
        xL, xR = s_prev[0] - self.ds, s_prev[-1] + self.ds
        dp, ddp = poly.deriv(), poly.deriv(2)
        return np.array([poly(xL), poly(xR), dp(xL), dp(xR), ddp(xL), ddp(xR)], dtype=float)

    # PRIVATE
    # This slices a region into num_regions slices of (approximately) equal size.
    @staticmethod
    def _balanced_slices(n, num_regions):
        base, rem = n // num_regions, n % num_regions
        slices, start = [], 0
        for i in range(num_regions):
            end = start + base + (1 if i < rem else 0)
            if end > start:
                slices.append(slice(start, end))
            start = end
        return slices

    def _fit_poly_side(self, field, deg, s_region, b_region, s_mid, num_slices, left_side):
        slices = self._balanced_slices(len(s_region), num_slices)
        # fit order: first piece next to the center, then outward
        slices_proc = list(reversed(slices)) if left_side else slices

        fit_reg = np.zeros_like(s_region, dtype=float)
        pieces = []
        prev_poly = None
        prev_s = None

        for ix, s in enumerate(slices_proc):
            s_this, b_this = s_region[s], b_region[s]
            if ix == 0:
                boundaries = self._boundary_from_sine(field, s_mid)
            else:
                boundaries = self._boundary_from_poly(prev_s, prev_poly)

            # ---- same constrained poly_fit logic you already have ----
            if deg >= 5:
                if left_side:
                    dbL = (-3 * b_this[0] + 4 * b_this[1] - b_this[2]) / (2 * self.ds)
                    d2L = (2 * b_this[0] - 5 * b_this[1] + 4 * b_this[2] - b_this[3]) / (self.ds ** 2)
                    coeffs = poly_fit.poly_fit(
                        N=deg, xdata=s_this, ydata=b_this,
                        x0=[s_this[0], s_this[-1]], y0=[b_this[0], boundaries[0]],
                        xp0=[s_this[0], s_this[-1]], yp0=[dbL, boundaries[2]],
                        xpp0=[s_this[0], s_this[-1]], ypp0=[d2L, boundaries[4]]
                    )
                else:
                    dbR = (3 * b_this[-1] - 4 * b_this[-2] + b_this[-3]) / (2 * self.ds)
                    d2R = (2 * b_this[-1] - 5 * b_this[-2] + 4 * b_this[-3] - b_this[-4]) / (self.ds ** 2)
                    coeffs = poly_fit.poly_fit(
                        N=deg, xdata=s_this, ydata=b_this,
                        x0=[s_this[0], s_this[-1]], y0=[boundaries[1], b_this[-1]],
                        xp0=[s_this[0], s_this[-1]], yp0=[boundaries[3], dbR],
                        xpp0=[s_this[0], s_this[-1]], ypp0=[d2R, boundaries[5]]
                    )
            elif deg >= 3:
                if left_side:
                    dbL = (-3 * b_this[0] + 4 * b_this[1] - b_this[2]) / (2 * self.ds)
                    coeffs = poly_fit.poly_fit(
                        N=deg, xdata=s_this, ydata=b_this,
                        x0=[s_this[0], s_this[-1]], y0=[b_this[0], boundaries[0]],
                        xp0=[s_this[0], s_this[-1]], yp0=[dbL, boundaries[2]]
                    )
                else:
                    dbR = (3 * b_this[-1] - 4 * b_this[-2] + b_this[-3]) / (2 * self.ds)
                    coeffs = poly_fit.poly_fit(
                        N=deg, xdata=s_this, ydata=b_this,
                        x0=[s_this[0], s_this[-1]], y0=[boundaries[1], b_this[-1]],
                        xp0=[s_this[0], s_this[-1]], yp0=[boundaries[3], dbR]
                    )
            else:
                if left_side:
                    coeffs = poly_fit.poly_fit(
                        N=deg, xdata=s_this, ydata=b_this,
                        x0=[s_this[0], s_this[-1]], y0=[b_this[0], boundaries[0]]
                    )
                else:
                    coeffs = poly_fit.poly_fit(
                        N=deg, xdata=s_this, ydata=b_this,
                        x0=[s_this[0], s_this[-1]], y0=[boundaries[1], b_this[-1]]
                    )
            # ----------------------------------------------------------

            poly = Polynomial(coeffs)
            fit_reg[s] = poly(s_this)
            pieces.append((s.start, poly))
            prev_poly, prev_s = poly, s_this

        # borders in strictly increasing s on this side
        slices_ord = sorted(slices, key=lambda sl: sl.stop)
        borders = [float(s_region[0])] + [float(s_region[sl.stop - 1]) for sl in slices_ord]
        return fit_reg, pieces, borders

    def _fit_edges(self):
        """
        Fit the left/right regions (outside the central sinusoid) with chained polynomials
        that connect to the CENTER with value/derivative continuity constraints.

        If `field` is None, fit all fields ("Bx","By","Bs"). Otherwise fit only the given field.

        Stores:
          - self.fit_data[fld] on the tails
          - self.fit_pars[fld]["enge_L"] and ["enge_R"] as LISTS of coefficient arrays (ascending powers)
        """

        for field in ["Bx", "By", "Bs"]:
            # center region slice and grid
            i0, i1 = self.borders_idx[field]
            mid_sl = slice(i0, i1)
            s_mid = self.s_full[mid_sl]

            # tails
            s_left = self.s_full[:i0]
            s_right = self.s_full[i1:]
            b_left = self.raw_data[field][:i0]
            b_right = self.raw_data[field][i1:]

            # degrees + number of chained pieces per side (configurable)
            degL = int(self.shapes[field]["poly_deg_L"])
            degR = int(self.shapes[field]["poly_deg_R"])
            nL = max(1, int(self.shapes[field].get("n_pieces_L", 3)))
            nR = max(1, int(self.shapes[field].get("n_pieces_R", 3)))

            nL = min(nL, max(1, len(s_left)))
            fitL, piecesL, bordersL = self._fit_poly_side(field, degL, s_left, b_left, s_mid, nL, left_side=True)
            self.fit_data[field][:i0] = fitL

            nR = min(nR, max(1, len(s_right)))
            fitR, piecesR, bordersR = self._fit_poly_side(field, degR, s_right, b_right, s_mid, nR, left_side=False)
            self.fit_data[field][i1:] = fitR

            # after computing fitL/piecesL and fitR/piecesR:
            self.fit_data[field][:i0] = fitL
            self.fit_data[field][i1:] = fitR

            # NEW: store coefficients (ascending-power) for exporter
            self.fit_pars[field]["enge_L"] = [p[1].coef for p in piecesL]  # order: near-center -> far-left
            self.fit_pars[field]["enge_R"] = [p[1].coef for p in piecesR]  # order: near-center -> far-right

            # existing border assembly (kept)
            self.poly_borders[field] = bordersL + [float(self.s_full[i0]), float(self.s_full[i1])] + bordersR[1:]

    ####################################################################################################################
    # TRANSVERSE GRADIENTS
    ####################################################################################################################

    # PRIVATE
    # This method extracts the data at (x,y) = (-1,0), (0,0), (1,0) and fits parabolas to these points.
    # This is done because bpmeth needs the derivatives w.r.t. x at each point.
    # The first derivatives are zero, but can be extracted nevertheless.
    def _fit_transverse_parabolas(self):
        subsetm10 = self.df.xs((-1, 0), level=["X", "Y"]).sort_index()
        subset00  = self.df.xs(( 0, 0), level=["X", "Y"]).sort_index()
        subsetp10 = self.df.xs(( 1, 0), level=["X", "Y"]).sort_index()

        parabolas = {"Bx": None, "By": None, "Bs": None}

        for field in ["Bx", "By", "Bs"]:
            x = [-self.dx, 0, self.dx]

            fieldm10 = subsetm10[field].to_numpy()
            field00  = subset00[field].to_numpy()
            fieldp10 = subsetp10[field].to_numpy()

            for ii in range(len(field00)):
                if parabolas[field] is None:
                    parabolas[field] = np.zeros((len(field00), 3))
                y = [fieldm10[ii], field00[ii], fieldp10[ii]]
                p = np.polyfit(x, y, 2)
                parabolas[field][ii, :] = p

            self.raw_data[field] = 2 * parabolas[field][:, 0]


    ####################################################################################################################
    # STRINGS FOR BPMETH
    ####################################################################################################################

    def _num(self, x, p=12):
        return f"{float(x):.{p}g}"

    def _poly_to_sympy(self, coeffs, p=12):
        terms = []
        for n, c in enumerate(coeffs):
            if c == 0:
                continue
            if n == 0:
                terms.append(self._num(c, p))
            elif n == 1:
                terms.append(f"{self._num(c, p)}*s")
            else:
                terms.append(f"{self._num(c, p)}*s**{n}")
        return " + ".join(terms) if terms else "0"

    def _sines_to_sympy(self, params, p=12):
        parts = []
        for Ac, As, k in zip(params[0::3], params[1::3], params[2::3]):
            parts.append(f"{Ac:.{p}g}*cos({k:.{p}g}*s) + {As:.{p}g}*sin({k:.{p}g}*s)")
        if (len(params) % 3) == 1:
            parts.append(f"{params[-1]:.{p}g}")
        return " + ".join(parts) if parts else "0"

    def export_piecewise_sympy(self, field="By", precision=12):
        i0, i1 = self.borders_idx[field]
        s = self.s_full
        sL, sR = s[:i0], s[i1:]
        s_min, s_max = float(s[0]), float(s[-1])
        center_right = float(s[i1 - 1]) if i1 > i0 else float(s[i0])

        # polynomials (ascending-power coeffs), order them from left->center and center->right
        L_coeffs = list(self.fit_pars[field]["enge_L"]) if "enge_L" in self.fit_pars[field] else []
        R_coeffs = list(self.fit_pars[field]["enge_R"]) if "enge_R" in self.fit_pars[field] else []
        # left list was fitted starting near center; reverse so it's leftmost..center
        L_coeffs = list(reversed(L_coeffs))

        # boundaries from the same slicing logic used in fitting
        nL = len(L_coeffs)
        nR = len(R_coeffs)

        bordersL = []
        if nL > 0 and len(sL) > 0:
            slL = self._balanced_slices(len(sL), nL)
            bordersL = [float(sL[sl.stop - 1]) for sl in slL]  # increasing, last ~ s[i0-1]

        bordersR = []
        if nR > 0 and len(sR) > 0:
            slR = self._balanced_slices(len(sR), nR)
            bordersR = [float(sR[sl.stop - 1]) for sl in slR]  # increasing, last == s[-1]

        # build piecewise tuples: (expr, cond)
        pieces = []

        # left pieces
        prev = s_min
        for j, cf in enumerate(L_coeffs):
            end = bordersL[j]
            expr = self._poly_to_sympy(cf, precision)
            cond = f"And({'s'} >= {self._num(prev, precision)}, {'s'} <= {self._num(end, precision)})"
            pieces.append(f"({expr}, {cond})")
            prev = end

        # center sinusoid
        sine_params = self.fit_pars[field].get("sines", [])
        if i1 > i0 and len(sine_params):
            start_c = bordersL[-1] if bordersL else float(s[i0 - 1]) if i0 > 0 else s_min
            expr_c = self._sines_to_sympy(sine_params, precision)
            cond_c = f"And({'s'} > {self._num(start_c, precision)}, {'s'} <= {self._num(center_right, precision)})"
            pieces.append(f"({expr_c}, {cond_c})")

        # right pieces
        prev = center_right
        for j, cf in enumerate(R_coeffs):
            end = bordersR[j]
            expr = self._poly_to_sympy(cf, precision)
            cond = f"And({'s'} > {self._num(prev, precision)}, {'s'} <= {self._num(end, precision)})"
            pieces.append(f"({expr}, {cond})")
            prev = end

        return "Piecewise(" + ", ".join(pieces) + ")"


    ####################################################################################################################
    # PLOTTING
    ####################################################################################################################

    @staticmethod
    def _integrate(data, ds):
        return sc.integrate.cumulative_trapezoid(data, initial=0) * ds

    def plot_integrated_fields(self):
        fig1, (ax1, ax2, ax3) = plt.subplots(3, figsize=(10, 4), constrained_layout=True)

        Bx_int_raw = self._integrate(self.raw_data["Bx"], self.ds)
        By_int_raw = self._integrate(self.raw_data["By"], self.ds)
        Bs_int_raw = self._integrate(self.raw_data["Bs"], self.ds)

        Bx_int_fit = self._integrate(self.fit_data["Bx"], self.ds)
        By_int_fit = self._integrate(self.fit_data["By"], self.ds)
        Bs_int_fit = self._integrate(self.fit_data["Bs"], self.ds)

        ax1.plot(self.s_full, Bx_int_raw, label='Raw Data')
        ax1.plot(self.s_full, Bx_int_fit, label='Fit', linestyle='--')
        ax2.plot(self.s_full, By_int_raw, label='Raw Data')
        ax2.plot(self.s_full, By_int_fit, label='Fit', linestyle='--')
        ax3.plot(self.s_full, Bs_int_raw, label='Raw Data')
        ax3.plot(self.s_full, Bs_int_fit, label='Fit', linestyle='--')

        # Add vertical lines at different positions for each subplot
        for field in ["Bx", "By", "Bs"]:
            for idx in self.borders_idx[field]:
                ax = {"Bx": ax1, "By": ax2, "Bs": ax3}[field]
                ax.axvline(x=self.s_full[idx], color='k', linestyle='--', linewidth=1)

        ax1.set_title(f"Integrated Magnetic Field at (X, Y) = {self.xy_point}")
        ax1.set_ylabel(r"Integrated Horizontal Field, $\int B_x \, ds$ [T·m]")
        ax2.set_ylabel(r"Integrated Vertical Field, $\int B_y \, ds$ [T·m]")
        ax3.set_ylabel(r"Integrated Longitudinal Field, $\int B_s \, ds$ [T·m]")
        ax3.set_xlabel(r"Longitudinal Position, $s$ [m]")

        ax1.legend(loc="lower right")
        ax2.legend(loc="lower right")
        ax3.legend(loc="upper right")

        # Turn on the grids.
        ax1.grid()
        ax2.grid()
        ax3.grid()

        plt.show()

    # PUBLIC
    # Plot the data against the fit.
    def plot_fields(self):
        fig1, (ax1, ax2, ax3) = plt.subplots(3, figsize=(10, 4), constrained_layout=True)

        ax1.plot(self.s_full, self.raw_data["Bx"])
        ax1.plot(self.s_full, self.fit_data["Bx"])
        ax2.plot(self.s_full, self.raw_data["By"])
        ax2.plot(self.s_full, self.fit_data["By"])
        ax3.plot(self.s_full, self.raw_data["Bs"])
        ax3.plot(self.s_full, self.fit_data["Bs"])

        # Add vertical lines at different positions for each subplot
        for field in ["Bx", "By", "Bs"]:
            for idx in self.borders_idx[field]:
                ax = {"Bx": ax1, "By": ax2, "Bs": ax3}[field]
                ax.axvline(x=self.s_full[idx], color='k', linestyle='--', linewidth=1)

        if self.der:
            x_label = r"$\frac{d^2 B_x}{d x^2}$"
            y_label = r"$\frac{d^2 B_y}{d y^2}$"
            s_label = r"$\frac{d^2 B_s}{d x^2}$"
        else:
            x_label = r"$B_x$"
            y_label = r"$B_y$"
            s_label = r"$B_s$"

        ax1.set_title(f"Magnetic Field at (X, Y) = {self.xy_point}")
        ax1.set_ylabel(f"Horizontal Field, {x_label} [T]")
        ax2.set_ylabel(f"Vertical Field, {y_label} [T]")
        ax3.set_ylabel(f"Longitudinal Field, {s_label} [T]")
        ax3.set_xlabel(r"Longitudinal Position, $s$ [m]")

        ax1.legend([f"{x_label} Data", f"{x_label} Fit"], loc="lower right")
        ax2.legend([f"{y_label} Data", f"{y_label} Fit"], loc="lower right")
        ax3.legend([f"{s_label} Data", f"{s_label} Fit"], loc="upper right")

        # Turn on the grids.
        ax1.grid()
        ax2.grid()
        ax3.grid()

        plt.show()