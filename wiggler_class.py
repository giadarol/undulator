# Compact, refactored Wiggler
# - Less duplication via helpers and component loops
# - Clear ensure() dependency gates
# - Generic sine-fitting used for fields and curvature
# - Small quality-of-life utilities (mid masks, magnitude, plotting core)
#
# Public API preserved (same method names), plus docstrings tightened.

from __future__ import annotations

import numpy as np
import pandas as pd
import scipy as sc
import sympy as sp
from scipy.signal import find_peaks
from scipy.optimize import curve_fit
from numpy.polynomial import Polynomial
import matplotlib.pyplot as plt
from scipy.special import expit


# ================================ Main class ================================

class Wiggler:

    def __init__(
        self,
        file_path,
        xy_point=(0, 0),
        dx=0.001,
        dy=0.001,
        ds=0.001,
        peak_window=(100, 2100),
        n_modes=[3, 3, 3],
        enge_deg = [[15, 15], [15, 15], [15, 15]],
        der=False,
        filter_params=None,
    ):

        self.file_path = file_path
        self.xy_point = xy_point
        self.dx, self.dy, self.ds = dx, dy, ds
        self.peak_window = peak_window

        # NOTE: Filter noise is now only used for the right tails, because those are noisy.
        # We can add a more general functionality later.
        self.filter_params = filter_params


        self.shapes = {
            "Bx": {"n_modes": n_modes[0], "enge_deg_L": enge_deg[0][0], "enge_deg_R": enge_deg[0][1]},
            "By": {"n_modes": n_modes[1], "enge_deg_L": enge_deg[1][0], "enge_deg_R": enge_deg[1][1]},
            "Bs": {"n_modes": n_modes[2], "enge_deg_L": enge_deg[2][0], "enge_deg_R": enge_deg[2][1]},
        }

        self.df = None
        self.s_full = None
        self.der = der

        # Dictionary that holds a list of borders for each field
        self.borders_idx = {"Bx": None, "By": None, "Bs": None}
        self.slices = {"Bx": None, "By": None, "Bs": None}

        # Data dictionaries
        # raw_data holds the data from the file
        # fit_data holds the data generated by fitting
        self.raw_data   = {"Bx": None, "By": None, "Bs": None}
        self.fit_data   = {"Bx": None, "By": None, "Bs": None}

        # Dictionary to hold lists of fitted parameters for each field component
        self.fit_pars = {
            "Bx": {
                "enge_L1": None, "enge_L2": None, "enge_L3": None,
                "sines": None,
                "enge_R1": None, "enge_R2": None, "enge_R3": None,
            },
            "By": {
                "enge_L1": None, "enge_L2": None, "enge_L3": None,
                "sines": None,
                "enge_R1": None, "enge_R2": None, "enge_R3": None,
            },
            "Bs": {
                "enge_L1": None, "enge_L2": None, "enge_L3": None,
                "sines": None,
                "enge_R1": None, "enge_R2": None, "enge_R3": None,
            },
        }


    # PUBLIC
    # Setter method that calls all the other methods to arrive at a fit.
    def set(self):
        self._parse_to_dataframe()
        self.select_xy()
        if self.filter_params != None:
            self._filter_noise()
        self._find_regions()
        self._fit_sinusoids()
        self._fit_enge()



    ####################################################################################################################
    # EVALUATION FUNCTIONS
    ####################################################################################################################

    # PRIVATE
    # This function evaluates a sum of (co)sines at the given x values.
    # The parameters are given as a flat list, where each mode has three parameters:
    #  - Amplitude of the cosine term
    #  - Amplitude of the sine term
    #  - Wave number
    # Thus, for n modes, the parameter list has length 3*n.
    @staticmethod
    def _sinusoid(x, *params):
        # Define the output array
        y = np.zeros_like(x, dtype=np.float64)

        # The range depends on the number of sinusoids there are present in the function.
        # B_x is best approximated with two, whereas B_y only needs one.
        # Note the integer division by 3, because each mode has three parameters.
        for A1, A2, k in zip(params[::3], params[1::3], params[2::3]):
            # General sinusoidal part is a linear combination of cosine and sine.
            # This is equivalent to a single function with a phase-offset, but more numerically stable.
            y += A1 * np.cos(k * x) + A2 * np.sin(k * x)

        return y

    # PRIVATE
    # This function evaluates an Enge function at the given x values.
    # The parameters are given as a list:
    #  - Amplitude
    #  - Coefficients of the polynomial in the exponent, starting from the constant term
    # Thus, for a polynomial of degree n, the parameter list has length n+2
    @staticmethod
    def _enge_function(x, y_off, amp, poly):
        return y_off + amp * expit(-poly(x))

    # PRIVATE
    # This function is a numerically safe logarithm, which is used in the inverse of the Enge function.
    @staticmethod
    def _inv_enge(y, A):
        """
        Numerically safe log(A/y - 1). Assumes y_pos has already been shifted positive.
        Clips to keep values strictly inside (0, A).
        """
        eps = np.finfo(float).eps
        y = np.clip(y, eps, A * (1.0 - 1e-8))
        return np.log(A / y - 1.0)



    ####################################################################################################################
    # IDENTIFYING REGIONS AND SETTING BORDERS IN DATA CLASSES
    ####################################################################################################################

    # PRIVATE
    # This method reads the data from the file and stores it in a pandas DataFrame.
    def _parse_to_dataframe(self) -> None:
        df = pd.read_csv(
            self.file_path, sep=r"\s+", header=None, names=["X", "Y", "Z", "Bx", "By", "Bs"]
        )
        df.set_index(["X", "Y", "Z"], inplace=True)
        self.df = df

    # PUBLIC
    # This method selects the data at the specified (x,y) point and stores it in the fields dictionary.
    # It is made public so that the user can change the (x,y) point and re-select the data without re-parsing the file.
    def select_xy(self):
        subset = self.df.xs(self.xy_point, level=["X", "Y"]).sort_index()

        self.s_full = subset.index.to_numpy() * self.ds

        # Store the raw data for each field.

        for field in ["Bx", "By", "Bs"]:
            if self.der == False:
                self.raw_data[field] = subset[field].to_numpy()

            else:
                self._fit_transverse_parabolas()

            self.fit_data[field] = np.zeros_like(self.raw_data[field])

    @staticmethod
    def find_sign_change_indices(y, eps=0.0):
        """
        Indices i where y[i] and y[i+1] have opposite signs.
        Exact zeros are not counted as crossings.

        eps > 0 treats |y| <= eps as 0 to add a small hysteresis.
        """
        y = np.asarray(y, float)
        if eps > 0:
            y = np.where(np.abs(y) <= eps, 0.0, y)

        y0 = y[:-1]
        y1 = y[1:]

        valid = ~np.isnan(y0) & ~np.isnan(y1)
        crossings = valid & (y0 * y1 < 0)  # strict sign change
        return np.flatnonzero(crossings)

    # PRIVATE
    # This method first finds the peaks and valleys in the data for Bx and By
    # Then, it combines them into one array for the extrema of Bx and By
    # Finally, it sets the borders_idx attribute of the FieldChannel objects for Bx and By
    def _find_regions(self):
        w_left = self.peak_window[0]
        w_right = self.peak_window[1]

        for field in ["Bx", "By", "Bs"]:
            field_peaks = find_peaks(self.raw_data[field])[0]
            field_valleys = find_peaks(-self.raw_data[field])[0]
            field_peaks = field_peaks[np.logical_and(field_peaks > w_left, field_peaks < w_right)]
            field_valleys = field_valleys[np.logical_and(field_valleys > w_left, field_valleys < w_right)]
            field_extrema = np.sort(np.concatenate((field_peaks, field_valleys)))
            if not self.der:
                self.borders_idx[field] = [field_extrema[0], field_extrema[1], field_extrema[2], field_extrema[-3], field_extrema[-2], field_extrema[-1]]
                self.slices[field] = []
                for i in range(len(self.borders_idx[field]) - 1):
                    self.slices[field].append(slice(self.borders_idx[field][i], self.borders_idx[field][i + 1]))
            else:
                self.borders_idx[field] = [field_extrema[0], field_extrema[1], field_extrema[2], field_extrema[-5], field_extrema[-4], field_extrema[-3]]
                self.slices[field] = []
                for i in range(len(self.borders_idx[field]) - 1):
                    self.slices[field].append(slice(self.borders_idx[field][i], self.borders_idx[field][i + 1]))


    # PRIVATE
    # This is an impromptu noise-filter.
    # Will probably need to be improved later.
    # For now, it only filters noise from the right tail of the data, because that's where the noise is present.
    def _filter_noise(self):
        from scipy.signal import savgol_filter
        from scipy.signal import medfilt

        left_idx = self.filter_params[0]
        right_idx = self.filter_params[1]
        kernel_size = self.filter_params[2]
        window_length = self.filter_params[3]
        polyorder = self.filter_params[4]

        for field in ["Bx", "By", "Bs"]:

            # Because Bs is very noisy, we also filter the left tail.
            # This is not necessary for Bx and By, because their left tails are not noisy.
            if field == "Bs":
                tail = slice(None, left_idx)
                m = medfilt(self.raw_data[field][tail].copy(), kernel_size=kernel_size)
                y_sm = savgol_filter(m, window_length=window_length, polyorder=polyorder)
                self.raw_data[field][tail] = y_sm

                tail = slice(right_idx, None)
                m = medfilt(self.raw_data[field][tail].copy(), kernel_size=kernel_size)  # kernel_size must be odd
                y_sm = savgol_filter(m, window_length=window_length, polyorder=polyorder)
                self.raw_data[field][tail] = y_sm

            tail = slice(right_idx, None)
            m = medfilt(self.raw_data[field][tail].copy(), kernel_size=kernel_size)  # kernel_size must be odd
            y_sm = savgol_filter(m, window_length=window_length, polyorder=polyorder)
            self.raw_data[field][tail] = y_sm



    ####################################################################################################################
    # SINUSOID FITTING
    ####################################################################################################################

    # PRIVATE
    # This function finds the amplitudes and frequencies of the (co)sines present in the data.
    @staticmethod
    def _find_modes(x, y, dx, n_modes):
        # Fourier Transform and frequencies
        fft = sc.fft.fft(y)
        fftfreq = sc.fft.fftfreq(len(x), dx)

        # Only keep positive frequencies
        fft = fft[fftfreq > 0]
        fftfreq = fftfreq[fftfreq > 0]

        # Find peaks in the magnitude spectrum
        peaks = find_peaks(np.abs(fft))[0]

        # Order peaks by magnitude, descending
        order = np.argsort(np.abs(fft[peaks]))[::-1]
        peaks = peaks[order][:n_modes]

        # Extract amplitudes and frequencies in the same order
        amplitudes = fft[peaks]
        cos_amps = 2 * dx * amplitudes.real
        sin_amps = -2 * dx * amplitudes.imag
        k_values = 2 * np.pi * fftfreq[peaks]

        return cos_amps, sin_amps, k_values

    # PRIVATE
    # This method fits sinusoids to the data in the regions defined by borders_idx.
    # The fitted parameters are stored in the fit_pars attribute.
    # The fitted data is stored in the fit_data attribute.
    # It uses the _find_modes function to get initial guesses for the parameters.
    def _fit_sinusoids(self, fun=True):
        for field in ["Bx", "By", "Bs"]:
            slice = self.slices[field][2]
            s_reg = self.s_full[slice]

            if fun:
                field_reg = self.raw_data[field][slice]
            else:
                field_reg = self.trans_der2[field][slice]

            n_modes = self.shapes[field]["n_modes"]

            cos_amps, sin_amps, k_modes = self._find_modes(s_reg, field_reg, self.ds, n_modes)

            p0 = np.zeros(n_modes*3)

            for ii in range(n_modes):
                p0[3 * ii] = cos_amps[ii]
                p0[3 * ii + 1] = sin_amps[ii]
                p0[3 * ii + 2] = k_modes[ii]

            popt, pcov = curve_fit(self._sinusoid, s_reg, field_reg, p0=p0)

            if fun:
                self.fit_pars[field]["sines"] = popt
                self.fit_data[field][slice] = self._sinusoid(s_reg, *popt)
            else:
                self.der2_fit_pars[field]["sines"] = popt
                self.fit_der2[field][slice] = self._sinusoid(s_reg, *popt)



    ####################################################################################################################
    # ENGE FITTING
    ####################################################################################################################
    # TODO: The method below works, but need to look if it can be tidied up.

    # PRIVATE
    # This method:
    #  - rescales x to lie between -1 and 1
    # Returns:
    #  - The rescaled x, defined as u
    #  - The polynomial that performs the rescaling
    @staticmethod
    def _rescale_x_for_enge(x):
        x_min = np.min(x)
        x_max = np.max(x)

        # Convert to u in [-1, 1]
        # Coefficients for linear transformation
        c_u0 = -(x_min + x_max) / (x_max - x_min)
        c_u1 = 2 / (x_max - x_min)
        poly_u = Polynomial([c_u0, c_u1])
        u = poly_u(x)

        return x_min, x_max, u, poly_u

    # PRIVATE
    # This method rescales y to be positive if necessary.
    # This is necessary to make sure that the logarithm is well-defined.
    @staticmethod
    def _rescale_y_for_enge(y):
        y_min = np.min(y)

        if y_min <= 0:
            y = y - y_min + 0.1

        return y

    from numpy.polynomial import Polynomial
    import numpy as np

    def _fit_polynomial(self, u, y_pos, A, deg):
        """
        Fit P(u) in monomial basis on u∈[-1,1] without covariance.
        Uses Polynomial.fit (no cov_x path), safe logit & finite masking.
        """
        t = self._inv_enge(y_pos, A)
        m = np.isfinite(u) & np.isfinite(t)
        u_m, t_m = u[m], t[m]
        if u_m.size == 0:
            return Polynomial([0.0]).convert(domain=[-1, 1], window=[-1, 1])

        deg_eff = int(min(deg, max(0, u_m.size - 1)))
        poly_u = Polynomial.fit(u_m, t_m, deg=deg_eff, domain=[-1, 1], window=[-1, 1])
        return poly_u.convert(kind=Polynomial, domain=[-1, 1], window=[-1, 1])

    # PRIVATE
    # This method computes the error for a given A value.
    # It first calculates an array of y, named yhat.
    # Then, it rescales A such that yhat matches y0, which is derived from the sinusoid fit.
    # Then, it recomputes yhat with the rescaled A.
    # This should return a fit that matches the y-value of the sinusoid fit at the border.
    def _error_for_A(self, y_off, A, x, y, y0, enge_side, deg=15):
        poly = self._fit_polynomial(x, y, A, deg=deg)
        y_hat = self._enge_function(x, y_off, A, poly)
        if enge_side == "enge_deg_L":
            A *= y0 / y_hat[-1]
        elif enge_side == "enge_deg_R":
            A *= y0 / y_hat[0]
        y_hat = self._enge_function(x, y_off, A, poly)
        return np.sum((y - y_hat) ** 2)

    # PRIVATE
    # This method fits Enge functions to the data in the regions defined by borders_idx.
    # The fitted parameters are stored in the fit_pars attribute.
    # The fitted data is stored in the fit_data attribute.
    # It uses the _fit_polynomial and _error_for_A functions to find the best fit.
    # TODO: It's not perfect yet. It might be nice to include a function that optimizes the degree of the polynomial.
    # TODO: That's similar to what we did before with the number of slices in the polynomial chain.
    # TODO: Note that now, we have four polynomials of order ~20, instead of ~20 polynomials of order 3.
    # TODO: So this is a good improvement, I'd say.
    def _fit_enge(self):
        """
        Fit three Enge pieces on each side, using your six borders and central sine slice:

        Left:  L1 = [:b0], L2 = [b0:b1], L3 = [b1:b2]  (L3 joins the center at b2)
        Right: R1 = [b3:b4], R2 = [b4:b5], R3 = [b5:]  (R1 joins the center at b3)

        For each piece we:
          - shift y positive (same shift used to match the border value),
          - scale s -> u in [-1,1],
          - scan A, fit P(u) in u, then write back and store params + u-map.
        """
        for field in ["Bx", "By", "Bs"]:
            b = self.borders_idx[field]  # [b0,b1,b2,b3,b4,b5]
            b0, b1, b2, b3, b4, b5 = b

            # convenience
            def deg(side):
                return int(self.shapes[field][side])

            # general slice fitter that matches to target value at the INNER border
            def fit_one_slice(s_sl, y_sl, y_target, side_key):
                # positivity shift
                b_min = float(np.min(y_sl))
                shift = (-b_min + 0.1) if (b_min <= 0) else 0.0
                y_tail = y_sl + shift
                y0 = float(y_target) + shift

                # s -> u in [-1,1]
                _, _, u, poly_u_lin = self._rescale_x_for_enge(s_sl)
                c0, c1 = map(float, poly_u_lin.coef)

                # pick degree by side
                d = deg("enge_deg_L" if side_key.startswith("L") else "enge_deg_R")

                # scan A and measure SSE after re-matching the border (in shifted space)
                ymax = float(np.max(y_tail))
                A_scan = np.linspace(ymax * 1.01, ymax * 3.0, 100)
                errs = [
                    self._error_for_A(shift, A, u, y_tail, y0=y0,
                                      enge_side=("enge_deg_L" if side_key.startswith("L") else "enge_deg_R"),
                                      deg=d)
                    for A in A_scan
                ]
                A_best = float(A_scan[int(np.argmin(errs))])

                # fit polynomial in u with chosen A
                poly_u = self._fit_polynomial(u, y_tail, A_best, deg=d)
                y_fit_u = self._enge_function(u, -shift, A_best, poly_u)

                pars = [-shift, A_best, *[float(c) for c in poly_u.coef]]
                u_map = [c0, c1]
                return y_fit_u, pars, u_map

            # ----- LEFT side (outer -> inner order depends on continuity target) -----
            # Inner-left L3: [b1:b2], match to sine at b2
            sL3 = self.s_full[b1:b2 + 1]
            yL3 = self.raw_data[field][b1:b2 + 1]
            y_join_L3 = self.fit_data[field][b2]  # sine value at inner border
            y_fit, pars, u_map = fit_one_slice(sL3, yL3, y_join_L3, "L3")
            self.fit_data[field][b1:b2 + 1] = y_fit
            self.fit_pars[field]["enge_L3"] = pars
            self.fit_pars[field]["enge_L3_u_map"] = u_map

            # Middle-left L2: [b0:b1], match to L3 at b1
            sL2 = self.s_full[b0:b1 + 1]
            yL2 = self.raw_data[field][b0:b1 + 1]
            y_join_L2 = self.fit_data[field][b1]
            y_fit, pars, u_map = fit_one_slice(sL2, yL2, y_join_L2, "L2")
            self.fit_data[field][b0:b1 + 1] = y_fit
            self.fit_pars[field]["enge_L2"] = pars
            self.fit_pars[field]["enge_L2_u_map"] = u_map

            # Outer-left L1: [:b0], match to L2 at b0
            sL1 = self.s_full[:b0 + 1]
            yL1 = self.raw_data[field][:b0 + 1]
            y_join_L1 = self.fit_data[field][b0]
            y_fit, pars, u_map = fit_one_slice(sL1, yL1, y_join_L1, "L1")
            self.fit_data[field][:b0 + 1] = y_fit
            self.fit_pars[field]["enge_L1"] = pars
            self.fit_pars[field]["enge_L1_u_map"] = u_map

            # ----- RIGHT side -----
            # Inner-right R1: [b3:b4], match to sine at b3
            sR1 = self.s_full[b3:b4 + 1]
            yR1 = self.raw_data[field][b3:b4 + 1]
            y_join_R1 = self.fit_data[field][b3]
            y_fit, pars, u_map = fit_one_slice(sR1, yR1, y_join_R1, "R1")
            self.fit_data[field][b3:b4 + 1] = y_fit
            self.fit_pars[field]["enge_R1"] = pars
            self.fit_pars[field]["enge_R1_u_map"] = u_map

            # Middle-right R2: [b4:b5], match to R1 at b4
            sR2 = self.s_full[b4:b5 + 1]
            yR2 = self.raw_data[field][b4:b5 + 1]
            y_join_R2 = self.fit_data[field][b4]
            y_fit, pars, u_map = fit_one_slice(sR2, yR2, y_join_R2, "R2")
            self.fit_data[field][b4:b5 + 1] = y_fit
            self.fit_pars[field]["enge_R2"] = pars
            self.fit_pars[field]["enge_R2_u_map"] = u_map

            # Outer-right R3: [b5:], match to R2 at b5
            sR3 = self.s_full[b5:]
            yR3 = self.raw_data[field][b5:]
            y_join_R3 = self.fit_data[field][b5]
            y_fit, pars, u_map = fit_one_slice(sR3, yR3, y_join_R3, "R3")
            self.fit_data[field][b5:] = y_fit
            self.fit_pars[field]["enge_R3"] = pars
            self.fit_pars[field]["enge_R3_u_map"] = u_map

    ####################################################################################################################
    # TRANSVERSE GRADIENTS
    ####################################################################################################################

    # PRIVATE
    # This method extracts the data at (x,y) = (-1,0), (0,0), (1,0) and fits parabolas to these points.
    # This is done because bpmeth needs the derivatives w.r.t. x at each point.
    # The first derivatives are zero, but can be extracted nevertheless.
    def _fit_transverse_parabolas(self):
        subsetm10 = self.df.xs((-1, 0), level=["X", "Y"]).sort_index()
        subset00  = self.df.xs(( 0, 0), level=["X", "Y"]).sort_index()
        subsetp10 = self.df.xs(( 1, 0), level=["X", "Y"]).sort_index()

        parabolas = {"Bx": None, "By": None, "Bs": None}

        for field in ["Bx", "By", "Bs"]:
            x = [-self.dx, 0, self.dx]

            fieldm10 = subsetm10[field].to_numpy()
            field00  = subset00[field].to_numpy()
            fieldp10 = subsetp10[field].to_numpy()

            for ii in range(len(field00)):
                if parabolas[field] is None:
                    parabolas[field] = np.zeros((len(field00), 3))
                y = [fieldm10[ii], field00[ii], fieldp10[ii]]
                p = np.polyfit(x, y, 2)
                parabolas[field][ii, :] = p

            self.raw_data[field] = 2 * parabolas[field][:, 0]


    ####################################################################################################################
    # STRINGS FOR BPMETH
    ####################################################################################################################

    @staticmethod
    def _poly_str(coeffs):
        terms = []
        for i, a in enumerate(coeffs):
            if i == 0:
                terms.append(f"({a})")
            elif i == 1:
                terms.append(f"({a})*s")
            else:
                terms.append(f"({a})*s**{i}")
        return " + ".join(terms) if terms else "0"

    def _enge_str(self, enge_pars):
        """enge_pars = [A, a0, a1, ..., aN]; Enge(s) = A * expit(-P_N(s)) = A/(1+exp(P_N(s)))."""

        # Extract Enge parameters from self.fit_pars

        y_off, A, *poly = enge_pars
        P = self._poly_str(poly)
        return f"{y_off} + ({A})/(1+exp(({P})))"

    @staticmethod
    def _sines_str(sine_pars):
        """
        sine_pars laid out as [A_cos1, A_sin1, k1, A_cos2, A_sin2, k2, ...].
        Returns sum_i (A_cosi*cos(k_i*s) + A_sini*sin(k_i*s)).
        """

        terms = []
        for i in range(0, len(sine_pars), 3):
            Aci, Asi, ki = sine_pars[i:i + 3]
            terms.append(f"({Aci})*cos(({ki})*s) + ({Asi})*sin(({ki})*s)")
        return " + ".join(terms)

    import sympy as sp

    def export_piecewise_string(self, component: str, sig=10, tol=1e-14):
        pars = self.fit_pars[component]

        fmtC = lambda x: f"{float(x):.{sig}g}"

        def poly_sum_u(coeffs_u, c0, c1):
            u = f"(({fmtC(c0)}) + ({fmtC(c1)})*s)"
            terms = []
            for k, ak in enumerate(coeffs_u):
                ak = fmtC(ak)
                if k == 0:
                    terms.append(f"({ak})")
                elif k == 1:
                    terms.append(f"({ak})*{u}")
                else:
                    terms.append(f"({ak})*{u}**{k}")
            return " + ".join(terms) if terms else "0"

        def enge_piece(key):
            pk = pars.get(key)
            y0, A, *au = pk
            c0, c1 = pars.get(f"{key}_u_map")
            P = poly_sum_u(au, c0, c1)
            return f"({fmtC(y0)}) + ({fmtC(A)})*(1 - tanh(({P})/2))/2"

        def sines_expr():
            a = pars.get("sines", [])
            terms = []
            for i in range(0, len(a), 3):
                c_amp, s_amp, k = a[i:i + 3]
                terms.append(f"({fmtC(c_amp)})*cos(({fmtC(k)})*s)")
                terms.append(f"({fmtC(s_amp)})*sin(({fmtC(k)})*s)")
            return " + ".join(terms) if terms else "0"

        # --- boundaries (FULL precision) ---
        b0, b1, b2, b3, b4, b5 = self.borders_idx[component]
        s0, s1, s2, s3, s4, s5 = (self.s_full[i] for i in (b0, b1, b2, b3, b4, b5))

        # --- pieces as strings ---
        L1_s = enge_piece("enge_L1")
        L2_s = enge_piece("enge_L2")
        L3_s = enge_piece("enge_L3")
        C_s = sines_expr()
        R1_s = enge_piece("enge_R1")
        R2_s = enge_piece("enge_R2")
        R3_s = enge_piece("enge_R3")

        # Turn strings into Sympy expressions ONCE
        s = sp.symbols("s")
        locals_map = {"s": s}  # exp/sin/cos are known to sympify already
        L1 = sp.sympify(L1_s, locals=locals_map)
        L2 = sp.sympify(L2_s, locals=locals_map)
        L3 = sp.sympify(L3_s, locals=locals_map)
        C = sp.sympify(C_s, locals=locals_map)
        R1 = sp.sympify(R1_s, locals=locals_map)
        R2 = sp.sympify(R2_s, locals=locals_map)
        R3 = sp.sympify(R3_s, locals=locals_map)

        # If your cut points are floats/np floats, this is fine
        s0, s1, s2, s3, s4, s5 = map(sp.sympify, [s0, s1, s2, s3, s4, s5])

        expr = sp.Piecewise(
            (L1, s < s0),
            (L2, (s >= s0) & (s < s1)),
            (L3, (s >= s1) & (s < s2)),
            (C, (s >= s2) & (s < s3)),
            (R1, (s >= s3) & (s < s4)),
            (R2, (s >= s4) & (s < s5)),
            (R3, s >= s5)
        )

        separate = [L1, L2, L3, C, R1, R2, R3]

        return expr, separate

    ####################################################################################################################
    # PLOTTING
    ####################################################################################################################

    @staticmethod
    def _integrate(data, ds):
        return np.cumsum(data) * ds

    def plot_integrated_fields(self):
        fig1, (ax1, ax2, ax3) = plt.subplots(3, figsize=(10, 4), constrained_layout=True)

        Bx_int_raw = self._integrate(self.raw_data["Bx"], self.ds)
        By_int_raw = self._integrate(self.raw_data["By"], self.ds)
        Bs_int_raw = self._integrate(self.raw_data["Bs"], self.ds)

        Bx_int_fit = self._integrate(self.fit_data["Bx"], self.ds)
        By_int_fit = self._integrate(self.fit_data["By"], self.ds)
        Bs_int_fit = self._integrate(self.fit_data["Bs"], self.ds)

        ax1.plot(self.s_full, Bx_int_raw, label='Raw Data')
        ax1.plot(self.s_full, Bx_int_fit, label='Fit', linestyle='--')
        ax2.plot(self.s_full, By_int_raw, label='Raw Data')
        ax2.plot(self.s_full, By_int_fit, label='Fit', linestyle='--')
        ax3.plot(self.s_full, Bs_int_raw, label='Raw Data')
        ax3.plot(self.s_full, Bs_int_fit, label='Fit', linestyle='--')

        # Add vertical lines at different positions for each subplot
        for field in ["Bx", "By", "Bs"]:
            for idx in self.borders_idx[field]:
                ax = {"Bx": ax1, "By": ax2, "Bs": ax3}[field]
                ax.axvline(x=self.s_full[idx], color='k', linestyle='--', linewidth=1)

        ax1.set_title(f"Integrated Magnetic Field at (X, Y) = {self.xy_point}")
        ax1.set_ylabel(r"Integrated Horizontal Field, $\int B_x \, ds$ [T·m]")
        ax2.set_ylabel(r"Integrated Vertical Field, $\int B_y \, ds$ [T·m]")
        ax3.set_ylabel(r"Integrated Longitudinal Field, $\int B_s \, ds$ [T·m]")
        ax3.set_xlabel(r"Longitudinal Position, $s$ [m]")

        ax1.legend(loc="lower right")
        ax2.legend(loc="lower right")
        ax3.legend(loc="upper right")

        # Turn on the grids.
        ax1.grid()
        ax2.grid()
        ax3.grid()

        plt.show()

    # PUBLIC
    # Plot the data against the fit.
    def plot_fields(self):
        fig1, (ax1, ax2, ax3) = plt.subplots(3, figsize=(10, 4), constrained_layout=True)

        ax1.plot(self.s_full, self.raw_data["Bx"])
        ax1.plot(self.s_full, self.fit_data["Bx"])
        ax2.plot(self.s_full, self.raw_data["By"])
        ax2.plot(self.s_full, self.fit_data["By"])
        ax3.plot(self.s_full, self.raw_data["Bs"])
        ax3.plot(self.s_full, self.fit_data["Bs"])

        # Add vertical lines at different positions for each subplot
        for field in ["Bx", "By", "Bs"]:
            for idx in self.borders_idx[field]:
                ax = {"Bx": ax1, "By": ax2, "Bs": ax3}[field]
                ax.axvline(x=self.s_full[idx], color='k', linestyle='--', linewidth=1)

        if self.der:
            x_label = r"$\frac{d^2 B_x}{d x^2}$"
            y_label = r"$\frac{d^2 B_y}{d y^2}$"
            s_label = r"$\frac{d^2 B_s}{d x^2}$"
        else:
            x_label = r"$B_x$"
            y_label = r"$B_y$"
            s_label = r"$B_s$"

        ax1.set_title(f"Magnetic Field at (X, Y) = {self.xy_point}")
        ax1.set_ylabel(f"Horizontal Field, {x_label} [T]")
        ax2.set_ylabel(f"Vertical Field, {y_label} [T]")
        ax3.set_ylabel(f"Longitudinal Field, {s_label} [T]")
        ax3.set_xlabel(r"Longitudinal Position, $s$ [m]")

        ax1.legend([f"{x_label} Data", f"{x_label} Fit"], loc="lower right")
        ax2.legend([f"{y_label} Data", f"{y_label} Fit"], loc="lower right")
        ax3.legend([f"{s_label} Data", f"{s_label} Fit"], loc="upper right")

        # Turn on the grids.
        ax1.grid()
        ax2.grid()
        ax3.grid()

        plt.show()